"""Unit tests for the main StaticRenderer orchestrator.

Note: The StaticRenderer now creates JSON API files and placeholder HTML files.
The actual HTML pages (index.html, archive.html, etc.) are generated by the
Vue SPA frontend. These tests verify the JSON and placeholder file creation.
"""

import json
import tempfile
from collections.abc import Generator
from datetime import UTC, datetime
from pathlib import Path

import pytest

from src.features.config.schemas.base import LinkType
from src.linker.models import Story, StoryLink
from src.ranker.models import RankerOutput
from src.renderer.metrics import RendererMetrics
from src.renderer.models import RunInfo, SourceStatus, SourceStatusCode
from src.renderer.renderer import StaticRenderer, render_static
from src.renderer.state_machine import RenderState


@pytest.fixture
def temp_output_dir() -> Generator[Path]:
    """Create a temporary output directory."""
    with tempfile.TemporaryDirectory() as tmpdir:
        yield Path(tmpdir)


@pytest.fixture
def sample_story() -> Story:
    """Create a sample story for testing."""
    return Story(
        story_id="test-story-1",
        title="Test Story Title",
        primary_link=StoryLink(
            url="https://example.com/article",
            link_type=LinkType.OFFICIAL,
            source_id="test-source",
            tier=0,
            title="Test Story Title",
        ),
        links=[
            StoryLink(
                url="https://example.com/article",
                link_type=LinkType.OFFICIAL,
                source_id="test-source",
                tier=0,
                title="Test Story Title",
            ),
        ],
        entities=["openai"],
        published_at=datetime(2026, 1, 15, 10, 0, 0, tzinfo=UTC),
    )


@pytest.fixture
def sample_ranker_output(sample_story: Story) -> RankerOutput:
    """Create sample ranker output."""
    return RankerOutput(
        top5=[sample_story],
        model_releases_by_entity={"openai": [sample_story]},
        papers=[],
        radar=[sample_story],
        output_checksum="abc123",
    )


@pytest.fixture
def sample_run_info() -> RunInfo:
    """Create sample run info."""
    return RunInfo(
        run_id="test-run-123",
        started_at=datetime(2026, 1, 15, 9, 0, 0, tzinfo=UTC),
        finished_at=datetime(2026, 1, 15, 9, 5, 0, tzinfo=UTC),
        success=True,
        items_total=100,
        stories_total=20,
    )


@pytest.fixture
def sample_source_status() -> SourceStatus:
    """Create sample source status."""
    return SourceStatus(
        source_id="test-source",
        name="Test Source",
        tier=0,
        method="rss_atom",
        status=SourceStatusCode.HAS_UPDATE,
        reason_code="ok",
        reason_text="Success",
        items_new=5,
        items_updated=2,
    )


class TestStaticRenderer:
    """Tests for StaticRenderer orchestrator.

    Note: The renderer now creates JSON API files and placeholder HTML files.
    HTML pages are generated by the Vue SPA frontend.
    """

    def test_initial_state_is_pending(self, temp_output_dir: Path) -> None:
        """Renderer starts in RENDER_PENDING state."""
        RendererMetrics.reset()
        renderer = StaticRenderer(run_id="test", output_dir=temp_output_dir)
        assert renderer.state == RenderState.RENDER_PENDING

    def test_successful_render_transitions_to_done(
        self,
        temp_output_dir: Path,
        sample_ranker_output: RankerOutput,
        sample_run_info: RunInfo,
        sample_source_status: SourceStatus,
    ) -> None:
        """Successful render ends in RENDER_DONE state."""
        RendererMetrics.reset()
        renderer = StaticRenderer(run_id="test", output_dir=temp_output_dir)

        result = renderer.render(
            ranker_output=sample_ranker_output,
            sources_status=[sample_source_status],
            run_info=sample_run_info,
            recent_runs=[sample_run_info],
        )

        assert result.success
        assert renderer.state == RenderState.RENDER_DONE

    def test_render_produces_json_and_placeholder(
        self,
        temp_output_dir: Path,
        sample_ranker_output: RankerOutput,
        sample_run_info: RunInfo,
        sample_source_status: SourceStatus,
    ) -> None:
        """Render produces JSON API files and placeholder HTML."""
        RendererMetrics.reset()
        renderer = StaticRenderer(run_id="test", output_dir=temp_output_dir)

        result = renderer.render(
            ranker_output=sample_ranker_output,
            sources_status=[sample_source_status],
            run_info=sample_run_info,
            recent_runs=[sample_run_info],
        )

        assert result.success
        # JSON API files
        assert (temp_output_dir / "api" / "daily.json").is_file()
        # Placeholder HTML in day/ directory
        day_files = list((temp_output_dir / "day").glob("*.html"))
        assert len(day_files) >= 1

    def test_render_manifest_contains_json_file(
        self,
        temp_output_dir: Path,
        sample_ranker_output: RankerOutput,
        sample_run_info: RunInfo,
        sample_source_status: SourceStatus,
    ) -> None:
        """Manifest lists generated JSON file."""
        RendererMetrics.reset()
        renderer = StaticRenderer(run_id="test", output_dir=temp_output_dir)

        result = renderer.render(
            ranker_output=sample_ranker_output,
            sources_status=[sample_source_status],
            run_info=sample_run_info,
            recent_runs=[sample_run_info],
        )

        # Manifest should have at least the JSON file
        assert len(result.manifest.files) >= 1
        paths = [f.path for f in result.manifest.files]
        assert "api/daily.json" in paths

    def test_render_manifest_has_checksums(
        self,
        temp_output_dir: Path,
        sample_ranker_output: RankerOutput,
        sample_run_info: RunInfo,
        sample_source_status: SourceStatus,
    ) -> None:
        """All files in manifest have SHA-256 checksums."""
        RendererMetrics.reset()
        renderer = StaticRenderer(run_id="test", output_dir=temp_output_dir)

        result = renderer.render(
            ranker_output=sample_ranker_output,
            sources_status=[sample_source_status],
            run_info=sample_run_info,
            recent_runs=[sample_run_info],
        )

        for file_info in result.manifest.files:
            assert len(file_info.sha256) == 64  # SHA-256 hex

    def test_render_empty_output(
        self,
        temp_output_dir: Path,
        sample_run_info: RunInfo,
    ) -> None:
        """Can render with empty ranker output."""
        RendererMetrics.reset()
        empty_output = RankerOutput(
            top5=[],
            model_releases_by_entity={},
            papers=[],
            radar=[],
        )

        renderer = StaticRenderer(run_id="test", output_dir=temp_output_dir)
        result = renderer.render(
            ranker_output=empty_output,
            sources_status=[],
            run_info=sample_run_info,
            recent_runs=[sample_run_info],
        )

        assert result.success

    def test_json_contains_story_data(
        self,
        temp_output_dir: Path,
        sample_ranker_output: RankerOutput,
        sample_run_info: RunInfo,
    ) -> None:
        """JSON output contains story data."""
        RendererMetrics.reset()
        renderer = StaticRenderer(run_id="test", output_dir=temp_output_dir)

        renderer.render(
            ranker_output=sample_ranker_output,
            sources_status=[],
            run_info=sample_run_info,
            recent_runs=[sample_run_info],
        )

        # Check JSON content
        json_path = temp_output_dir / "api" / "daily.json"
        with open(json_path) as f:
            data = json.load(f)

        assert "top5" in data
        assert len(data["top5"]) > 0
        assert data["top5"][0]["title"] == "Test Story Title"

    def test_archive_dates_tracked_via_json(
        self,
        temp_output_dir: Path,
        sample_ranker_output: RankerOutput,
        sample_run_info: RunInfo,
    ) -> None:
        """Archive dates are tracked in date-specific JSON files."""
        RendererMetrics.reset()

        # Create pre-existing JSON files to simulate history
        api_day_dir = temp_output_dir / "api" / "day"
        api_day_dir.mkdir(parents=True)
        (api_day_dir / "2026-01-14.json").write_text('{"run_date": "2026-01-14"}')

        renderer = StaticRenderer(run_id="test", output_dir=temp_output_dir)
        renderer.render(
            ranker_output=sample_ranker_output,
            sources_status=[],
            run_info=sample_run_info,
            recent_runs=[sample_run_info],
        )

        # Both dates should have JSON files
        json_files = list(api_day_dir.glob("*.json"))
        dates = [f.stem for f in json_files]
        assert "2026-01-14" in dates


class TestRenderStaticFunction:
    """Tests for render_static pure function."""

    def test_render_static_works(
        self,
        temp_output_dir: Path,
        sample_ranker_output: RankerOutput,
    ) -> None:
        """render_static function works with minimal args."""
        RendererMetrics.reset()

        result = render_static(
            ranker_output=sample_ranker_output,
            output_dir=temp_output_dir,
            run_id="test-pure",
        )

        assert result.success
        # Should create JSON file
        assert (temp_output_dir / "api" / "daily.json").is_file()

    def test_render_static_with_all_args(
        self,
        temp_output_dir: Path,
        sample_ranker_output: RankerOutput,
        sample_run_info: RunInfo,
        sample_source_status: SourceStatus,
    ) -> None:
        """render_static works with all arguments."""
        RendererMetrics.reset()

        result = render_static(
            ranker_output=sample_ranker_output,
            output_dir=temp_output_dir,
            run_id="test-full",
            timezone="Asia/Taipei",
            sources_status=[sample_source_status],
            run_info=sample_run_info,
            recent_runs=[sample_run_info],
        )

        assert result.success
